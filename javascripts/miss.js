// Generated by CoffeeScript 1.7.1
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  (function(document) {
    var Miss, backdrop, colorConvert, coords, extend, gravity, message, miss, prepHex, showHideEl;
    miss = function(selector, options) {
      var defaults, el, els, i, sel, _i, _len, _results;
      if (selector == null) {
        selector = null;
      }
      if (options == null) {
        options = null;
      }
      miss.missies = miss.missies || {};
      if (!miss.global) {
        miss.settings();
      }
      defaults = {
        order: 'series',
        background_color: '#f5f5f5',
        titlebar_color: '#939393',
        font_color: '#000'
      };
      if (selector) {
        els = document.querySelectorAll.call(document, selector);
        sel = selector.replace(/\./g, '_class_').replace(/\#/g, '_id_').replace(/[^a-zA-Z0-9]/g, '_');
        _results = [];
        for (i = _i = 0, _len = els.length; _i < _len; i = ++_i) {
          el = els[i];
          _results.push(miss.missies[sel + '_' + i] = new Miss(el, i, extend(defaults, options)));
        }
        return _results;
      }
    };
    Miss = (function() {
      function Miss(el, i, opts) {
        this.buildBox = __bind(this.buildBox, this);
        this.el = el;
        this.coords = coords(this.el);
        this.order = this.el.dataset.missOrder || 100 + i;
        this.opts = extend(opts, miss.global);
        this.title = this.opts.title || this.el.dataset.missTitle || null;
        this.msg = message(this.opts.msg) || message(this.el.dataset.missMsg) || null;
        backdrop(true);
        if (!!(this.title || this.msg)) {
          this.buildBox();
        }
      }

      Miss.prototype.buildBox = function() {
        var box, li, msg_box, title_box, _i, _len, _ref;
        box = document.createElement('div');
        box.id = "miss_" + this.order;
        box.className = 'miss-box';
        box.style.position = 'fixed';
        title_box = document.createElement('div');
        title_box.className = 'miss-titlebar';
        title_box.innerHTML = this.title;
        msg_box = document.createElement('div');
        msg_box.className = 'miss-msg';
        msg_box.innerHTML = this.msg;
        if (!miss.global.theme) {
          box.style.backgroundColor = this.opts.background_color;
          box.style.borderRadius = "3px";
          box.style.maxWidth = "20%";
          box.style.maxHeight = "40%";
          title_box.style.backgroundColor = this.opts.titlebar_color;
          title_box.style.borderTopLeftRadius = "3px";
          title_box.style.borderTopRightRadius = "3px";
          title_box.style.padding = '8px';
          msg_box.style.padding = '8px';
          _ref = msg_box.querySelectorAll('li');
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            li = _ref[_i];
            li.style.listStyle = 'disc inside';
          }
        }
        box.appendChild(title_box);
        box.appendChild(msg_box);
        box.style.visibility = 'hidden';
        miss.bd.appendChild(box);
        this.gravity = gravity(this.coords, box.offsetHeight, box.offsetWidth);
        box.style.top = "" + this.gravity.x + "px";
        box.style.left = "" + this.gravity.y + "px";
        return box.style.visibility = '';
      };

      return Miss;

    })();
    showHideEl = function(el, toggle) {
      if (miss.global.compat.hidden) {
        if (toggle) {
          return el.removeAttribute('hidden') && (el.style.display = '');
        } else {
          return el.setAttribute('hidden', true);
        }
      } else if (toggle) {
        return el.style.display = '';
      } else {
        return el.style.display = 'none';
      }
    };
    extend = function(objA, objB) {
      var attr;
      for (attr in objB) {
        objA[attr] = objB[attr];
      }
      return objA;
    };
    colorConvert = function(hex) {
      return {
        red: parseInt((prepHex(hex)).substring(0, 2), 16),
        green: parseInt((prepHex(hex)).substring(2, 4), 16),
        blue: parseInt((prepHex(hex)).substring(4, 6), 16)
      };
    };
    prepHex = function(hex) {
      hex = (hex.charAt(0) === "#" ? hex.split("#")[1] : hex);
      if (hex.length === 3) {
        return hex + hex;
      } else {
        return hex;
      }
    };
    coords = function(el) {
      var rect;
      rect = el.getBoundingClientRect();
      return {
        top: rect.top,
        right: rect.right,
        bottom: rect.bottom,
        left: rect.left,
        width: rect.width || rect.right - rect.left,
        height: rect.height || rect.bottom - rect.top
      };
    };
    gravity = function(coords, height, width) {
      var ary_x, ary_y, box_center, center, el_center, k, map_x, map_y, optimal_x, optimal_y, v, x, xk, xv, y, yk, yv, _ref, _ref1, _ref2, _ref3;
      ary_x = [];
      ary_y = [];
      center = {
        x: miss.bd.offsetHeight / 2,
        y: miss.bd.offsetWidth / 2
      };
      el_center = {
        x: coords.height / 2,
        y: coords.width / 2
      };
      box_center = {
        x: height / 2,
        y: width / 2
      };
      map_x = [
        {
          diff: {
            top: Math.abs(coords.top - box_center.x - center.x),
            middle: Math.abs(coords.top - center.x),
            bottom: Math.abs(coords.top + box_center.x - center.x)
          },
          val: {
            top: coords.top - height,
            middle: coords.top - box_center.x,
            bottom: coords.top
          },
          position: 'top'
        }, {
          diff: {
            top: Math.abs(coords.top + el_center.x - box_center.x - center.x),
            middle: Math.abs(coords.top + el_center.x - center.x),
            bottom: Math.abs(coords.top + el_center.x + box_center.x - center.x)
          },
          val: {
            top: coords.top + el_center.x - height,
            middle: coords.top + el_center.x - box_center.x,
            bottom: coords.top + el_center.x
          },
          position: 'middle'
        }, {
          diff: {
            top: Math.abs(coords.bottom - box_center.x - center.x),
            middle: Math.abs(coords.bottom - center.x),
            bottom: Math.abs(coords.bottom + box_center.x - center.x)
          },
          val: {
            top: coords.bottom - height,
            middle: coords.bottom - box_center.x,
            bottom: coords.bottom
          },
          position: 'bottom'
        }
      ];
      map_y = [
        {
          diff: {
            left: Math.abs(coords.left - box_center.y - center.y),
            middle: Math.abs(coords.left - center.y),
            right: Math.abs(coords.left + box_center.y - center.y)
          },
          val: {
            left: coords.left - width,
            middle: coords.left - box_center.y,
            right: coords.left
          },
          position: 'left'
        }, {
          diff: {
            left: Math.abs(coords.left + el_center.y - box_center.y - center.y),
            middle: Math.abs(coords.left + el_center.y - center.y),
            right: Math.abs(coords.left + el_center.y + box_center.y - center.y)
          },
          val: {
            left: coords.left + el_center.y - width,
            middle: coords.left + el_center.y - box_center.y,
            right: coords.left + el_center.y
          },
          position: 'middle'
        }, {
          diff: {
            left: Math.abs(coords.right - box_center.y - center.y),
            middle: Math.abs(coords.right - center.y),
            right: Math.abs(coords.right + box_center.y - center.y)
          },
          val: {
            left: coords.right - width,
            middle: coords.right - box_center.y,
            right: coords.right
          },
          position: 'right'
        }
      ];
      for (k in map_x) {
        v = map_x[k];
        _ref = v['diff'];
        for (xk in _ref) {
          xv = _ref[xk];
          ary_x.push(xv);
        }
      }
      for (k in map_y) {
        v = map_y[k];
        _ref1 = v['diff'];
        for (yk in _ref1) {
          yv = _ref1[yk];
          ary_y.push(yv);
        }
      }
      optimal_x = ary_x.sort(function(a, b) {
        return a - b;
      })[0];
      optimal_y = ary_y.sort(function(a, b) {
        return a - b;
      })[0];
      for (k in map_x) {
        v = map_x[k];
        _ref2 = v['diff'];
        for (xk in _ref2) {
          xv = _ref2[xk];
          if (xv === optimal_x) {
            x = {
              val: v.val[xk],
              position: "" + v['position'] + "_" + xk
            };
          }
        }
      }
      for (k in map_y) {
        v = map_y[k];
        _ref3 = v['diff'];
        for (yk in _ref3) {
          yv = _ref3[yk];
          if (yv === optimal_y) {
            y = {
              val: v.val[yk],
              position: "" + v['position'] + "_" + yk
            };
          }
        }
      }
      return {
        x: x.val,
        y: y.val
      };
    };
    backdrop = function(toggle) {
      var bd, opts, rgb;
      if (!document.getElementById('miss_bd')) {
        opts = miss.global;
        rgb = colorConvert(opts.backdrop_color);
        bd = document.createElement('div');
        bd.id = 'miss_bd';
        bd.style.backgroundColor = "rgba(" + rgb.red + ", " + rgb.green + ", " + rgb.blue + ", " + opts.backdrop_opacity + ")";
        bd.style.position = 'fixed';
        bd.style.zIndex = opts.z_index;
        bd.style.top = 0;
        bd.style.right = 0;
        bd.style.bottom = 0;
        bd.style.left = 0;
        showHideEl(bd, false);
        document.body.appendChild(bd);
      }
      bd = document.getElementById('miss_bd');
      miss.bd = bd;
      return showHideEl(bd, toggle);
    };
    message = function(msg) {
      var msg_el;
      if (/#{(.*?)}/.test(msg)) {
        msg_el = document.querySelector(msg.match(/#{(.*?)}/)[1]);
        showHideEl(msg_el, false);
        return msg_el.innerHTML;
      } else {
        return msg;
      }
    };
    miss.settings = function(set) {
      return miss.global = extend({
        theme: null,
        trigger: null,
        key_on: null,
        key_off: null,
        key_hover: null,
        backdrop_color: '#000',
        backdrop_opacity: 0.3,
        z_index: 2100,
        compat: {
          hidden: !!('hidden' in document.createElement('div'))
        }
      }, set);
    };
    miss.on = function() {
      return backdrop(true);
    };
    miss.off = function() {
      return backdrop(false);
    };
    miss.destroy = (function(_this) {
      return function() {
        var el;
        el = document.getElementById("miss_bd");
        el.parentNode.removeChild(el);
        return delete _this.miss;
      };
    })(this);
    return this.miss = miss;
  })(document);

}).call(this);
